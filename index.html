<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Akakios - Coming Soon</title>
    
    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; style-src 'self' 'unsafe-inline' fonts.googleapis.com; font-src fonts.gstatic.com; script-src 'self' 'unsafe-inline';">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta name="referrer" content="no-referrer">
    
    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <!-- Modern comforting fonts with font-display for performance -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        background: #000;
        overflow: hidden;
        cursor: none;
        /* Performance optimizations */
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        text-rendering: optimizeSpeed;
        /* Disable GPU-intensive features on low-end devices */
        will-change: auto;
      }
      
      /* Reduce motion for accessibility and performance */
      @media (prefers-reduced-motion: reduce) {
        *, *::before, *::after {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
        }
        #lightning-canvas {
          display: none !important;
        }
      }

      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        /* Performance: Use transform3d to enable hardware acceleration efficiently */
        transform: translate3d(0, 0, 0);
      }      /* Optimized Copper Ball Cursor with Negative Sign */
      #cursor-icon {
        position: fixed;
        top: 0;
        left: 0;
        width: 20px;
        height: 20px;
        pointer-events: none;
        transform: translate3d(-50%, -50%, 0);
        z-index: 1000;
        /* Performance: Will-change only when needed */
        will-change: transform;
      }
      
      /* Copper ball with negative sign - optimized for performance */
      #cursor-icon::before {
        content: 'âˆ’';
        position: absolute;
        width: 20px;
        height: 20px;
        
        /* Simplified gradient for better performance */
        background: radial-gradient(circle at 30% 30%, 
          #FFB347 0%, #D2691E 50%, #8B4513 100%);
        
        border: 1px solid #654321;
        border-radius: 50%;
        
        /* Reduced box-shadow complexity for performance */
        box-shadow: 
          inset 2px 2px 4px rgba(255, 255, 255, 0.4),
          0 2px 6px rgba(0, 0, 0, 0.3);
        
        display: flex;
        align-items: center;
        justify-content: center;
        color: #2F1B14;
        font-size: 14px;
        font-weight: bold;
        font-family: Arial, sans-serif;
        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.3);
      }

      /* Tesla Coil Structure */
      .tesla-coil {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 5;
        pointer-events: none;
      }
      
      .coil-base {
        width: 80px;
        height: 30px;
        background: linear-gradient(to bottom, #444, #222);
        border: 2px solid #666;
        border-radius: 8px;
        position: relative;
      }
      
      .coil-base::before {
        content: '';
        position: absolute;
        top: -5px;
        left: 10px;
        right: 10px;
        height: 8px;
        background: linear-gradient(to right, #888, #555, #888);
        border-radius: 4px;
      }
      
      .coil-tower {
        width: 12px;
        height: 120px;
        background: linear-gradient(to right, #666, #444, #666);
        border: 1px solid #888;
        margin: -2px auto 0;
        position: relative;
      }
      
      .coil-tower::before,
      .coil-tower::after {
        content: '';
        position: absolute;
        left: -8px;
        right: -8px;
        height: 3px;
        background: linear-gradient(to right, #888, #555, #888);
        border-radius: 2px;
      }
      
      .coil-tower::before {
        top: 30%;
      }
      
      .coil-tower::after {
        top: 60%;
      }
      
      .coil-top {
        width: 24px;
        height: 24px;
        background: radial-gradient(circle at 30% 30%, #aaa, #666, #333);
        border: 2px solid #888;
        border-radius: 50%;
        margin: -2px auto;
        position: relative;
        box-shadow: 
          0 0 10px rgba(100, 200, 255, 0.5),
          inset 2px 2px 4px rgba(255, 255, 255, 0.3);
      }
      
      /* Optimized Interactive HD Text Style with Performance Improvements */
      h1 {
        font-family: 'Poppins', sans-serif;
        font-weight: 600;
        font-size: 12vw;
        text-align: center;
        position: relative;
        margin-bottom: 20px;
        
        /* CSS variables for mouse position and dynamic colors */
        --mouse-x: -9999px;
        --mouse-y: -9999px;
        --glow-opacity: 0;
        --fire-intensity: 0;
        --blue-intensity: 0;

        /* Optimized gradient with fewer color stops */
        background-image: 
          radial-gradient(
            circle 250px at var(--mouse-x) var(--mouse-y),
            rgba(255, 80, 20, var(--fire-intensity)),
            rgba(255, 120, 40, calc(var(--fire-intensity) * 0.7)) 50%,
            transparent 75%
          ),
          radial-gradient(
            circle 220px at var(--mouse-x) var(--mouse-y),
            rgba(20, 180, 255, var(--blue-intensity)),
            rgba(100, 220, 255, calc(var(--blue-intensity) * 0.7)) 50%,
            transparent 85%
          );
        
        background-clip: text;
        -webkit-background-clip: text;
        color: transparent;
        
        /* Reduced text effects for performance */
        -webkit-text-stroke: 1px rgba(180, 180, 180, 0.8);
        text-shadow: 
          0 0 30px rgba(255, 80, 40, calc(var(--fire-intensity) * 0.8)),
          0 0 40px rgba(20, 180, 255, calc(var(--blue-intensity) * 0.6));

        user-select: none;
        transition: all 0.3s ease-out;
        
        /* Performance: Enable hardware acceleration only when needed */
        will-change: background-image;
        
        /* Optimized animation with fewer keyframes */
        animation: gentle-pulse 4s ease-in-out infinite;
      }

      @keyframes gentle-pulse {
        0%, 100% {
          filter: brightness(1);
          transform: scale(1);
        }
        50% {
          filter: brightness(1.1);
          transform: scale(1.005);
        }
      }      /* Optimized Coming Soon text styling */
      .coming-soon {
        font-family: 'Inter', sans-serif;
        font-weight: 400;
        font-size: 2.0vw;
        text-align: center;
        color: rgba(180, 180, 180, 0.9);
        text-transform: uppercase;
        letter-spacing: 0.5em;
        margin-top: -10px;
        text-shadow: 
          0 0 25px rgba(255, 100, 60, 0.4),
          0 0 35px rgba(40, 180, 255, 0.3);
        user-select: none;
        
        /* Optimized animation with longer duration for less CPU usage */
        animation: bright-pulse 3s ease-in-out infinite alternate;
      }

      @keyframes bright-pulse {
        from {
          opacity: 0.8;
          transform: scale(1);
        }
        to {
          opacity: 1;
          transform: scale(1.01);
        }
      }      /* Tesla Canvas optimization */
      #tesla-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10;
        /* Performance: Use GPU acceleration efficiently */
        will-change: contents;
      }
      
      /* Performance optimization for low-end devices */
      @media (max-width: 768px), (pointer: coarse) {
        #tesla-canvas {
          display: none;
        }
        .tesla-coil {
          display: none;
        }
        h1 {
          background-image: linear-gradient(45deg, #FF5014, #14B4FF);
          animation-duration: 6s;
        }
        .coming-soon {
          animation-duration: 4s;
        }
      }
    </style>
  </head>  <body>
    <!-- Tesla Coil Structure -->
    <div class="tesla-coil">
      <div class="coil-base"></div>
      <div class="coil-tower"></div>
      <div class="coil-top"></div>
    </div>
    
    <h1>Akakios</h1>
    <div class="coming-soon">Coming Soon</div>
    <canvas id="tesla-canvas"></canvas>
    <!-- custom cursor icon -->
    <div id="cursor-icon"></div>    <script>
      // Performance Optimized Tesla Coil Effects
      (function() {
        'use strict';
        
        // Lightweight performance config for Tesla coil
        const TESLA_CONFIG = {
          maxFPS: 45, // Reduced for better performance
          maxArcs: 5, // Limit concurrent electricity arcs
          arcLifetime: 0.8, // Seconds each arc lasts
          minDistanceForArc: 50, // Minimum distance to create arc
          maxArcDistance: 400, // Maximum arc reach
          sparkCount: 3, // Sparks per arc
          updateInterval: 100 // Milliseconds between arc updates
        };
        
        // Detect low-end devices
        const isLowEndDevice = navigator.hardwareConcurrency <= 2 || 
                              (navigator.deviceMemory && navigator.deviceMemory < TESLA_CONFIG.lowEndDeviceThreshold);
        
        if (isLowEndDevice) {
          TESLA_CONFIG.maxFPS = 30;
          TESLA_CONFIG.maxArcs = 3;
          TESLA_CONFIG.sparkCount = 2;
          TESLA_CONFIG.updateInterval = 150;
        }
        
        // Secure DOM references
        const canvas = document.getElementById('tesla-canvas');
        const cursorIcon = document.getElementById('cursor-icon');
        const h1 = document.querySelector('h1');
        const teslaCoil = document.querySelector('.tesla-coil');
        
        if (!canvas || !cursorIcon || !h1 || !teslaCoil) {
          console.warn('Required elements not found');
          return;
        }
        
        const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
        let { width, height } = updateCanvasSize();
        
        // Tesla coil position (fixed at bottom center)
        const teslaTop = {
          x: width / 2,
          y: height - 60 // Position above the coil visual
        };
        
        // Mouse and arc state
        let mouseX = width / 2;
        let mouseY = height / 2;
        let electricArcs = [];
        let lastArcTime = 0;
        
        // Performance tracking
        let lastFrameTime = 0;
        const fpsInterval = 1000 / TESLA_CONFIG.maxFPS;
        
        // Dynamic color system
        let colorPhase = 0;
        let lastColorChange = 0;
        
        function updateCanvasSize() {
          const dpr = Math.min(window.devicePixelRatio || 1, 2);
          const rect = canvas.getBoundingClientRect();
          
          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;
          
          ctx.scale(dpr, dpr);
          canvas.style.width = rect.width + 'px';
          canvas.style.height = rect.height + 'px';
          
          // Update tesla position
          teslaTop.x = rect.width / 2;
          teslaTop.y = rect.height - 60;
          
          return { width: rect.width, height: rect.height };
        }
        
        // Throttled mouse handler for better performance
        let mouseThrottle = null;
        function handleMouseMove(e) {
          if (mouseThrottle) return;
          
          mouseThrottle = setTimeout(() => {
            mouseThrottle = null;
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            // Update cursor position
            cursorIcon.style.transform = `translate3d(${e.clientX - 10}px, ${e.clientY - 10}px, 0)`;
            
            // Update text effects
            updateTextEffects();
            
            // Create new arc if conditions are met
            createElectricArc();
          }, TESLA_CONFIG.updateInterval);
        }
        
        function updateTextEffects() {
          if (!h1) return;
          
          const rect = h1.getBoundingClientRect();
          const isOverText = mouseX >= rect.left && mouseX <= rect.right && 
                            mouseY >= rect.top && mouseY <= rect.bottom;
          
          if (isOverText) {
            const x = mouseX - rect.left;
            const y = mouseY - rect.top;
            h1.style.setProperty('--mouse-x', `${x}px`);
            h1.style.setProperty('--mouse-y', `${y}px`);
            updateDynamicColors();
          } else {
            h1.style.setProperty('--fire-intensity', '0');
            h1.style.setProperty('--blue-intensity', '0');
          }
        }
        
        function updateDynamicColors() {
          const now = Date.now();
          
          if (now - lastColorChange > 3000) {
            colorPhase = Math.random();
            lastColorChange = now;
          }
          
          const intensity = (Math.sin(now * 0.002) + 1) * 0.4; // Reduced intensity
          
          if (colorPhase < 0.5) {
            h1.style.setProperty('--fire-intensity', intensity.toString());
            h1.style.setProperty('--blue-intensity', (intensity * 0.3).toString());
          } else {
            h1.style.setProperty('--fire-intensity', (intensity * 0.3).toString());
            h1.style.setProperty('--blue-intensity', intensity.toString());
          }
        }
        
        function createElectricArc() {
          const now = Date.now();
          
          // Don't create too many arcs
          if (electricArcs.length >= TESLA_CONFIG.maxArcs) return;
          
          const distance = Math.sqrt((mouseX - teslaTop.x) ** 2 + (mouseY - teslaTop.y) ** 2);
          
          // Only create arc if cursor is within range and not too close
          if (distance < TESLA_CONFIG.minDistanceForArc || distance > TESLA_CONFIG.maxArcDistance) {
            return;
          }
          
          // Create new electric arc
          const arc = {
            startX: teslaTop.x,
            startY: teslaTop.y,
            endX: mouseX,
            endY: mouseY,
            life: TESLA_CONFIG.arcLifetime,
            maxLife: TESLA_CONFIG.arcLifetime,
            branches: []
          };
          
          // Create branching points for more realistic electricity
          const numBranches = Math.min(3, Math.floor(distance / 100));
          for (let i = 0; i < numBranches; i++) {
            const t = (i + 1) / (numBranches + 1);
            const branchX = arc.startX + (arc.endX - arc.startX) * t + (Math.random() - 0.5) * 30;
            const branchY = arc.startY + (arc.endY - arc.startY) * t + (Math.random() - 0.5) * 30;
            
            arc.branches.push({
              x: branchX,
              y: branchY,
              angle: Math.random() * Math.PI * 2,
              length: 15 + Math.random() * 20
            });
          }
          
          electricArcs.push(arc);
        }
        
        function drawElectricArc(arc) {
          const opacity = arc.life / arc.maxLife;
          if (opacity <= 0) return;
          
          // Main arc from Tesla coil to cursor
          drawLightningBolt(arc.startX, arc.startY, arc.endX, arc.endY, opacity);
          
          // Draw branches
          arc.branches.forEach(branch => {
            const endX = branch.x + Math.cos(branch.angle) * branch.length;
            const endY = branch.y + Math.sin(branch.angle) * branch.length;
            drawLightningBolt(branch.x, branch.y, endX, endY, opacity * 0.6);
          });
        }
        
        function drawLightningBolt(x1, y1, x2, y2, opacity) {
          const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
          if (distance < 10) return;
          
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          
          // Create jagged lightning path
          const segments = Math.max(3, Math.floor(distance / 25));
          for (let i = 1; i <= segments; i++) {
            const t = i / segments;
            let x = x1 + (x2 - x1) * t;
            let y = y1 + (y2 - y1) * t;
            
            // Add randomness except for the end point
            if (i < segments) {
              const maxOffset = Math.min(15, distance * 0.15);
              x += (Math.random() - 0.5) * maxOffset;
              y += (Math.random() - 0.5) * maxOffset;
            }
            
            ctx.lineTo(x, y);
          }
          
          // Electric blue lightning
          ctx.strokeStyle = `rgba(100, 200, 255, ${opacity * 0.9})`;
          ctx.lineWidth = 1.5 + opacity * 2;
          ctx.shadowColor = 'rgba(100, 200, 255, 1)';
          ctx.shadowBlur = 5 + opacity * 10;
          ctx.stroke();
          
          // Inner bright core
          ctx.strokeStyle = `rgba(200, 230, 255, ${opacity * 0.7})`;
          ctx.lineWidth = 0.5 + opacity;
          ctx.shadowBlur = 2 + opacity * 5;
          ctx.stroke();
        }
        
        function animate(currentTime) {
          // FPS limiting
          if (currentTime - lastFrameTime < fpsInterval) {
            requestAnimationFrame(animate);
            return;
          }
          lastFrameTime = currentTime;
          
          // Clear canvas
          ctx.clearRect(0, 0, width, height);
          ctx.globalCompositeOperation = 'lighter';
          
          // Update and draw electric arcs
          for (let i = electricArcs.length - 1; i >= 0; i--) {
            const arc = electricArcs[i];
            arc.life -= 1 / 60; // Decay over time
            
            if (arc.life <= 0) {
              electricArcs.splice(i, 1);
              continue;
            }
            
            drawElectricArc(arc);
          }
          
          ctx.globalCompositeOperation = 'source-over';
          requestAnimationFrame(animate);
        }
        
        // Event listeners
        window.addEventListener('mousemove', handleMouseMove, { passive: true });
        
        window.addEventListener('click', (e) => {
          // Create multiple arcs on click for dramatic effect
          for (let i = 0; i < 2; i++) {
            setTimeout(() => createElectricArc(), i * 50);
          }
        }, { passive: true });
        
        window.addEventListener('resize', () => {
          ({ width, height } = updateCanvasSize());
        }, { passive: true });
        
        // Cleanup on page visibility change
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            electricArcs.length = 0;
            if (mouseThrottle) {
              clearTimeout(mouseThrottle);
              mouseThrottle = null;
            }
          }
        });
        
        // Start the animation
        requestAnimationFrame(animate);
        
        // Cleanup
        window.addEventListener('beforeunload', () => {
          electricArcs.length = 0;
          if (mouseThrottle) {
            clearTimeout(mouseThrottle);
          }
        });
        
      })();
    </script>
  </body>
</html>