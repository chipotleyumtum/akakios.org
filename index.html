<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <title>akakios-website</title>    <!-- Modern comforting fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        background: #000;
        overflow: hidden; /* Hide scrollbars */
        cursor: none; /* Hide default cursor, as we have lightning */
      }      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;}      /* Copper Ball Cursor with Negative Sign */
      #cursor-icon {
        position: fixed;
        top: 0;
        left: 0;
        width: 20px;
        height: 20px;
        pointer-events: none;
        transform: translate(-50%, -50%);
        z-index: 1000;
      }
      
      /* Copper ball with negative sign */
      #cursor-icon::before {
        content: 'âˆ’';
        position: absolute;
        width: 20px;
        height: 20px;
        
        /* Copper gradient for metallic look */
        background: radial-gradient(circle at 30% 30%, 
          #FFB347 0%,      /* Light copper highlight */
          #D2691E 40%,     /* Medium copper */
          #B8860B 70%,     /* Dark copper */
          #8B4513 100%);   /* Copper shadow */
        
        border: 1px solid #654321;
        border-radius: 50%;
        
        /* Metallic depth and shine */
        box-shadow: 
          inset 2px 2px 4px rgba(255, 255, 255, 0.4),
          inset -2px -2px 4px rgba(0, 0, 0, 0.4),
          0 2px 6px rgba(0, 0, 0, 0.3);
        
        /* Center the negative sign */
        display: flex;
        align-items: center;
        justify-content: center;
        color: #2F1B14;
        font-size: 14px;
        font-weight: bold;
        font-family: Arial, sans-serif;
        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.3);
      }      /* Interactive HD Text Style with Bright Dynamic Colors */
      h1 {
        font-family: 'Poppins', sans-serif; /* Modern, comforting font */
        font-weight: 600;
        font-size: 12vw;
        text-align: center;
        position: relative;
        margin-bottom: 20px;
        
        /* CSS variables for mouse position and dynamic colors */
        --mouse-x: -9999px;
        --mouse-y: -9999px;
        --glow-opacity: 0;
        --fire-intensity: 0;
        --blue-intensity: 0;

        /* Bright dynamic color mixing background */
        background-image: 
          radial-gradient(
            circle 250px at var(--mouse-x) var(--mouse-y),
            rgba(255, 80, 20, var(--fire-intensity)), /* Bright orange-red */
            rgba(255, 120, 40, calc(var(--fire-intensity) * 0.9)) 25%,
            rgba(255, 60, 60, calc(var(--fire-intensity) * 0.8)) 40%,
            rgba(255, 40, 80, calc(var(--fire-intensity) * 0.6)) 60%,
            transparent 75%
          ),
          radial-gradient(
            circle 220px at var(--mouse-x) var(--mouse-y),
            rgba(20, 180, 255, var(--blue-intensity)), /* Bright electric blue */
            rgba(60, 200, 255, calc(var(--blue-intensity) * 0.9)) 30%,
            rgba(100, 220, 255, calc(var(--blue-intensity) * 0.7)) 50%,
            rgba(140, 240, 255, calc(var(--blue-intensity) * 0.5)) 70%,
            transparent 85%
          );
        
        background-clip: text;
        -webkit-background-clip: text;
        color: transparent;
        
        /* Brighter fallback outline */
        -webkit-text-stroke: 1px rgba(180, 180, 180, 0.8);
        text-shadow: 
          0 0 30px rgba(255, 80, 40, calc(var(--fire-intensity) * 1.2)),
          0 0 40px rgba(20, 180, 255, calc(var(--blue-intensity) * 1.0)),
          0 0 15px rgba(200, 200, 200, 0.4);

        user-select: none;
        transition: all 0.2s ease-out;
        
        /* Subtle animation for extra appeal */
        animation: gentle-pulse 3s ease-in-out infinite;
      }

      @keyframes gentle-pulse {
        0%, 100% {
          filter: brightness(1) saturate(1.1);
          transform: scale(1);
        }
        50% {
          filter: brightness(1.15) saturate(1.3);
          transform: scale(1.01);
        }
      }      /* Coming Soon text styling */
      .coming-soon {
        font-family: 'Inter', sans-serif; /* Clean modern font */
        font-weight: 400;
        font-size: 2.0vw;
        text-align: center;
        color: rgba(180, 180, 180, 0.9);
        text-transform: uppercase;
        letter-spacing: 0.5em;
        margin-top: -10px;
        text-shadow: 
          0 0 25px rgba(255, 100, 60, 0.6),
          0 0 35px rgba(40, 180, 255, 0.5),
          0 0 15px rgba(200, 200, 200, 0.3);
        user-select: none;
        
        /* Bright pulsing animation */
        animation: bright-pulse 2.5s ease-in-out infinite alternate;
      }

      @keyframes bright-pulse {
        from {
          opacity: 0.8;
          text-shadow: 
            0 0 25px rgba(255, 100, 60, 0.6),
            0 0 35px rgba(40, 180, 255, 0.5),
            0 0 15px rgba(200, 200, 200, 0.3);
          transform: scale(1);
        }
        to {
          opacity: 1;
          text-shadow: 
            0 0 35px rgba(255, 120, 80, 0.9),
            0 0 45px rgba(60, 200, 255, 0.8),
            0 0 25px rgba(220, 220, 220, 0.5);
          transform: scale(1.02);
        }
      }

      #lightning-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10; 
      }
    </style>
  </head>  <body>
    <h1>Akakios</h1>
    <div class="coming-soon">Coming Soon</div>
    <canvas id="lightning-canvas"></canvas>
    <!-- custom cursor icon -->
    <div id="cursor-icon"></div>

    <script>
      const canvas = document.getElementById('lightning-canvas');
      const ctx = canvas.getContext('2d');
      let width = canvas.width = window.innerWidth;
      let height = canvas.height = window.innerHeight;

      let mouseX = width / 2;
      let mouseY = height / 2;
      const lightningSegments = [];
      const maxSegments = 25; // Number of segments in the lightning trail
      const MIN_DIST_FOR_TRAIL = 10; // Min pixels mouse must move to add new segment
      let lastTrailPoint = { x: mouseX, y: mouseY };      const h1 = document.querySelector('h1');

      // Lightning Bursts on Click
      const lightningBursts = [];

      // Dynamic color system
      let colorPhase = 0;
      let lastColorChange = 0;
      const COLOR_CHANGE_INTERVAL = 2000; // Change colors every 2 seconds

      window.addEventListener('mousemove', e => {
        mouseX = e.clientX;
        mouseY = e.clientY;

        const cursorIcon = document.getElementById('cursor-icon');
        cursorIcon.style.left = e.clientX + 'px';
        cursorIcon.style.top = e.clientY + 'px';

        if (h1) {
          const rect = h1.getBoundingClientRect();
          // Check if mouse is within h1 bounds
          if (mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom) {
            const x = mouseX - rect.left;
            const y = mouseY - rect.top;
            h1.style.setProperty('--mouse-x', `${x}px`);
            h1.style.setProperty('--mouse-y', `${y}px`);
            
            // Dynamic color switching
            updateDynamicColors();
          } else {
            h1.style.setProperty('--fire-intensity', '0');
            h1.style.setProperty('--blue-intensity', '0');
          }
        }
      });

      function updateDynamicColors() {
        const now = Date.now();
        
        // Change color phase periodically or randomly
        if (now - lastColorChange > COLOR_CHANGE_INTERVAL || Math.random() < 0.001) {
          colorPhase = Math.random();
          lastColorChange = now;
        }
        
        // Mix of time-based and random color intensity
        const timeBasedIntensity = (Math.sin(now * 0.003) + 1) / 2;
        const randomFactor = 0.3 + Math.random() * 0.7;
          if (colorPhase < 0.5) {
          // Bright Fire mode
          const fireIntensity = timeBasedIntensity * randomFactor * 1.3; // Increased brightness
          const blueIntensity = (1 - fireIntensity) * 0.4;
          
          h1.style.setProperty('--fire-intensity', Math.min(fireIntensity, 1).toString());
          h1.style.setProperty('--blue-intensity', blueIntensity.toString());
        } else {
          // Bright Blue mode
          const blueIntensity = timeBasedIntensity * randomFactor * 1.2; // Increased brightness
          const fireIntensity = (1 - blueIntensity) * 0.3;
          
          h1.style.setProperty('--fire-intensity', fireIntensity.toString());
          h1.style.setProperty('--blue-intensity', Math.min(blueIntensity, 1).toString());
        }
      }
      
      if (h1) {
        // Ensure glow turns off if mouse leaves body/window quickly from H1
        document.body.addEventListener('mouseleave', () => {
             h1.style.setProperty('--glow-opacity', '0');
        });
      }


      window.addEventListener('resize', () => {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        lastTrailPoint = { x: mouseX, y: mouseY }; // Reset last point on resize
      });

      window.addEventListener('click', e => {
        createLightningBurst(e.clientX, e.clientY);
      });

      function createLightningBurst(x, y) {
        const burst = { x, y, particles: [], life: 1.0, maxLife: 1.0 };
        const numParticles = 15 + Math.floor(Math.random() * 10); // 15-24 particles
        for (let i = 0; i < numParticles; i++) {
          const angle = Math.random() * Math.PI * 2;
          const length = 30 + Math.random() * 40; // Length of each spark
          const speed = 1 + Math.random(); // How fast particle moves/extends
          burst.particles.push({
            x1: x, y1: y,
            targetX2: x + Math.cos(angle) * length,
            targetY2: y + Math.sin(angle) * length,
            currentX2: x, currentY2: y, // Start at center
            speed: speed,
            brightness: 0.7 + Math.random() * 0.3
          });
        }
        lightningBursts.push(burst);
      }

      function drawLightningSegment(x1, y1, x2, y2, brightness, baseWidth = 1) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        
        const segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        const numJaggedPoints = Math.max(3, Math.floor(segmentLength / 20));
        let currentX = x1;
        let currentY = y1;

        for (let i = 1; i <= numJaggedPoints; i++) {
          const t = i / numJaggedPoints;
          let nextX = x1 + t * (x2 - x1);
          let nextY = y1 + t * (y2 - y1);
          if (i < numJaggedPoints) {
            const maxOffset = Math.min(20, segmentLength * 0.25); // Jaggedness proportional to length, capped
            const offsetX = (Math.random() - 0.5) * maxOffset * (1 - t * 0.5); 
            const offsetY = (Math.random() - 0.5) * maxOffset * (1 - t * 0.5);
            nextX += offsetX;
            nextY += offsetY;
          }
          ctx.lineTo(nextX, nextY);
        }
        
        // Core
        ctx.strokeStyle = `rgba(0, 229, 255, ${brightness * 0.8})`;
        ctx.lineWidth = baseWidth + brightness * 1.5;
        ctx.shadowColor = 'rgba(0, 229, 255, 1)';
        ctx.shadowBlur = 5 + brightness * 10;
        ctx.stroke();

        // Outer Glow
        ctx.strokeStyle = `rgba(200, 255, 255, ${brightness * 0.5})`;
        ctx.lineWidth = baseWidth * 2 + brightness * 3;
        ctx.shadowColor = 'rgba(100, 255, 255, 0.8)';
        ctx.shadowBlur = 10 + brightness * 15;
        ctx.stroke();
      }

      function animate() {
        ctx.clearRect(0, 0, width, height);
        ctx.globalCompositeOperation = 'lighter'; // Additive blending for glow effects

        // Lightning Trail
        const distMoved = Math.sqrt(Math.pow(mouseX - lastTrailPoint.x, 2) + Math.pow(mouseY - lastTrailPoint.y, 2));
        if (distMoved > MIN_DIST_FOR_TRAIL) {
          lightningSegments.push({ x: mouseX, y: mouseY, life: 1.0 });
          if (lightningSegments.length > maxSegments) {
            lightningSegments.shift();
          }
          lastTrailPoint = { x: mouseX, y: mouseY };
        } else if (lightningSegments.length > 0) {
            // If mouse is still but trail exists, ensure the head of the trail is at the mouse
            // This makes the trail "catch up" if MIN_DIST_FOR_TRAIL was large
            // lightningSegments[lightningSegments.length - 1].x = mouseX;
            // lightningSegments[lightningSegments.length - 1].y = mouseY;
            // Commented out: this can make the trail head jumpy if mouse moves slightly less than MIN_DIST
        }


        for (let i = lightningSegments.length - 1; i >= 0; i--) {
          const p = lightningSegments[i];
          p.life -= 0.04; // Fade out speed
          if (p.life <= 0) {
            lightningSegments.splice(i, 1);
            continue;
          }
          if (i > 0) { // Draw segment from this point to the previous one
            const prev_p = lightningSegments[i-1];
            drawLightningSegment(p.x, p.y, prev_p.x, prev_p.y, p.life);
          } else if (lightningSegments.length === 1){ // Single point, draw small spark
             // drawLightningSegment(p.x -1, p.y -1, p.x+1, p.y+1, p.life * 0.5, 0.5);
          }
        }
        
        // Lightning Bursts
        for (let i = lightningBursts.length - 1; i >= 0; i--) {
          const burst = lightningBursts[i];
          burst.life -= 0.035; // Burst fade speed

          if (burst.life <= 0) {
            lightningBursts.splice(i, 1);
            continue;
          }

          burst.particles.forEach(p => {
            // Particles expand outwards
            const progress = 1 - (burst.life / burst.maxLife); // 0 to 1
            p.currentX2 = p.x1 + (p.targetX2 - p.x1) * progress * p.speed;
            p.currentY2 = p.y1 + (p.targetY2 - p.y1) * progress * p.speed;
            
            // Fade particle brightness with burst life
            drawLightningSegment(p.x1, p.y1, p.currentX2, p.currentY2, burst.life * p.brightness, 0.5);
          });
        }

        ctx.globalCompositeOperation = 'source-over'; // Reset composite operation
        requestAnimationFrame(animate);
      }
      animate();
    </script>
  </body>
</html>