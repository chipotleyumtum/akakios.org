<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Akakios - Coming Soon</title>
    
    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; style-src 'self' 'unsafe-inline' fonts.googleapis.com; font-src fonts.gstatic.com; script-src 'self' 'unsafe-inline';">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta name="referrer" content="no-referrer">
    
    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <!-- Modern comforting fonts with font-display for performance -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        background: #000;
        overflow: hidden;
        cursor: none;
        /* Performance optimizations */
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        text-rendering: optimizeSpeed;
        /* Disable GPU-intensive features on low-end devices */
        will-change: auto;
      }
      
      /* Reduce motion for accessibility and performance */
      @media (prefers-reduced-motion: reduce) {
        *, *::before, *::after {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
        }
        #lightning-canvas {
          display: none !important;
        }
      }

      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        /* Performance: Use transform3d to enable hardware acceleration efficiently */
        transform: translate3d(0, 0, 0);
      }      /* Optimized Copper Ball Cursor with Negative Sign */
      #cursor-icon {
        position: fixed;
        top: 0;
        left: 0;
        width: 20px;
        height: 20px;
        pointer-events: none;
        transform: translate3d(-50%, -50%, 0);
        z-index: 1000;
        /* Performance: Will-change only when needed */
        will-change: transform;
      }
      
      /* Copper ball with negative sign - optimized for performance */
      #cursor-icon::before {
        content: 'âˆ’';
        position: absolute;
        width: 20px;
        height: 20px;
        
        /* Simplified gradient for better performance */
        background: radial-gradient(circle at 30% 30%, 
          #FFB347 0%, #D2691E 50%, #8B4513 100%);
        
        border: 1px solid #654321;
        border-radius: 50%;
        
        /* Reduced box-shadow complexity for performance */
        box-shadow: 
          inset 2px 2px 4px rgba(255, 255, 255, 0.4),
          0 2px 6px rgba(0, 0, 0, 0.3);
        
        display: flex;
        align-items: center;
        justify-content: center;
        color: #2F1B14;
        font-size: 14px;
        font-weight: bold;
        font-family: Arial, sans-serif;
        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.3);
      }      /* Optimized Interactive HD Text Style with Performance Improvements */
      h1 {
        font-family: 'Poppins', sans-serif;
        font-weight: 600;
        font-size: 12vw;
        text-align: center;
        position: relative;
        margin-bottom: 20px;
        
        /* CSS variables for mouse position and dynamic colors - START EMPTY */
        --mouse-x: 50%;
        --mouse-y: 50%;
        --fire-intensity: 0;
        --blue-intensity: 0;

        /* Copper and blue gradients that only appear on hover */
        background-image: 
          radial-gradient(
            circle 200px at var(--mouse-x) var(--mouse-y),
            rgba(255, 179, 71, var(--fire-intensity)) 0%,
            rgba(210, 105, 30, calc(var(--fire-intensity) * 0.8)) 40%,
            transparent 70%
          ),
          radial-gradient(
            circle 180px at var(--mouse-x) var(--mouse-y),
            rgba(100, 200, 255, var(--blue-intensity)) 0%,
            rgba(20, 180, 255, calc(var(--blue-intensity) * 0.8)) 40%,
            transparent 70%
          );
        
        background-clip: text;
        -webkit-background-clip: text;
        color: transparent;
        
        /* White outline - always visible */
        -webkit-text-stroke: 2px rgba(255, 255, 255, 0.9);
        
        /* Only show glow when hovering */
        text-shadow: 
          0 0 20px rgba(255, 179, 71, calc(var(--fire-intensity) * 0.6)),
          0 0 30px rgba(100, 200, 255, calc(var(--blue-intensity) * 0.6));

        user-select: none;
        transition: all 0.4s ease-out;
        
        /* Performance: Enable hardware acceleration only when needed */
        will-change: background-image;
        
        /* Subtle pulse animation */
        animation: gentle-pulse 6s ease-in-out infinite;
      }

      @keyframes gentle-pulse {
        0%, 100% {
          filter: brightness(1);
          transform: scale(1);
        }
        50% {
          filter: brightness(1.1);
          transform: scale(1.005);
        }
      }      /* Optimized Coming Soon text styling */
      .coming-soon {
        font-family: 'Inter', sans-serif;
        font-weight: 400;
        font-size: 2.0vw;
        text-align: center;
        color: rgba(180, 180, 180, 0.9);
        text-transform: uppercase;
        letter-spacing: 0.5em;
        margin-top: -10px;
        text-shadow: 
          0 0 25px rgba(255, 100, 60, 0.4),
          0 0 35px rgba(40, 180, 255, 0.3);
        user-select: none;
        
        /* Optimized animation with longer duration for less CPU usage */
        animation: bright-pulse 3s ease-in-out infinite alternate;
      }

      @keyframes bright-pulse {
        from {
          opacity: 0.8;
          transform: scale(1);
        }
        to {
          opacity: 1;
          transform: scale(1.01);
        }
      }

      /* Canvas optimization */
      #lightning-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10;
        /* Performance: Use GPU acceleration efficiently */
        will-change: contents;
      }
      
      /* Performance optimization for low-end devices */
      @media (max-width: 768px), (pointer: coarse) {
        #lightning-canvas {
          display: none;
        }
        h1 {
          background-image: linear-gradient(45deg, #FF5014, #14B4FF);
          animation-duration: 6s;
        }
        .coming-soon {
          animation-duration: 4s;
        }
      }
    </style>
  </head>  <body>
    <h1>Akakios</h1>
    <div class="coming-soon">Coming Soon</div>
    <canvas id="lightning-canvas"></canvas>
    <!-- custom cursor icon -->
    <div id="cursor-icon"></div>    <script>
      // Performance and Security Optimized Lightning Effects
      (function() {
        'use strict';
        
        // Performance monitoring and throttling
        const PERFORMANCE_CONFIG = {
          maxFPS: 60,
          maxSegments: 15, // Reduced from 25
          maxBursts: 3, // Limit concurrent bursts
          minDistForTrail: 15, // Increased to reduce calculations
          adaptiveQuality: true,
          lowEndDeviceThreshold: 4 // GB RAM threshold
        };
        
        // Detect low-end devices and reduce effects
        const isLowEndDevice = navigator.hardwareConcurrency <= 2 || 
                              (navigator.deviceMemory && navigator.deviceMemory < PERFORMANCE_CONFIG.lowEndDeviceThreshold);
        
        if (isLowEndDevice) {
          PERFORMANCE_CONFIG.maxSegments = 8;
          PERFORMANCE_CONFIG.maxBursts = 2;
          PERFORMANCE_CONFIG.maxFPS = 30;
          PERFORMANCE_CONFIG.minDistForTrail = 25;
        }
        
        // Secure DOM element references
        const canvas = document.getElementById('lightning-canvas');
        const cursorIcon = document.getElementById('cursor-icon');
        const h1 = document.querySelector('h1');
        
        if (!canvas || !cursorIcon || !h1) {
          console.warn('Required elements not found');
          return;
        }
        
        const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
        let { width, height } = updateCanvasSize();
        
        // Optimized state management
        let mouseX = width / 2;
        let mouseY = height / 2;
        let lastMouseX = mouseX;
        let lastMouseY = mouseY;
        let isMouseMoving = false;
        let lastMoveTime = 0;
        
        // Throttled arrays with automatic cleanup
        const lightningSegments = [];
        const lightningBursts = [];
        let lastTrailPoint = { x: mouseX, y: mouseY };
        
        // Performance tracking
        let frameCount = 0;
        let lastFrameTime = 0;
        let actualFPS = 60;
        const fpsInterval = 1000 / PERFORMANCE_CONFIG.maxFPS;
        
        // Dynamic color system - optimized
        let colorPhase = 0;
        let lastColorChange = 0;
        const COLOR_CHANGE_INTERVAL = 3000; // Increased interval
        
        // Throttled mouse movement handler
        let mouseMoveThrottle = null;
        const MOUSE_THROTTLE_MS = 16; // ~60fps
        
        function updateCanvasSize() {
          const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap pixel ratio
          const rect = canvas.getBoundingClientRect();
          
          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;
          
          ctx.scale(dpr, dpr);
          canvas.style.width = rect.width + 'px';
          canvas.style.height = rect.height + 'px';
          
          return { width: rect.width, height: rect.height };
        }
        
        function throttledMouseMove(e) {
          if (mouseMoveThrottle) return;
          
          mouseMoveThrottle = setTimeout(() => {
            mouseMoveThrottle = null;
            
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            isMouseMoving = Math.abs(mouseX - lastMouseX) > 1 || Math.abs(mouseY - lastMouseY) > 1;
            lastMoveTime = Date.now();
            
            // Optimized cursor position update
            cursorIcon.style.transform = `translate3d(${e.clientX - 10}px, ${e.clientY - 10}px, 0)`;
            
            updateTextEffects();
          }, MOUSE_THROTTLE_MS);
        }
        
        function updateTextEffects() {
          if (!h1) return;
          
          const rect = h1.getBoundingClientRect();
          const isOverText = mouseX >= rect.left && mouseX <= rect.right && 
                            mouseY >= rect.top && mouseY <= rect.bottom;
          
          if (isOverText) {
            const x = mouseX - rect.left;
            const y = mouseY - rect.top;
            h1.style.setProperty('--mouse-x', `${x}px`);
            h1.style.setProperty('--mouse-y', `${y}px`);
            updateDynamicColors();
          } else {
            h1.style.setProperty('--fire-intensity', '0');
            h1.style.setProperty('--blue-intensity', '0');
          }
        }
          function updateDynamicColors() {
          const now = Date.now();
          
          // Create alternating copper and blue waves
          const time = now * 0.003;
          const wave1 = (Math.sin(time) + 1) * 0.5;
          const wave2 = (Math.sin(time + Math.PI * 0.5) + 1) * 0.5;
          
          // Alternate between copper-dominant and blue-dominant
          const copperIntensity = 0.7 + wave1 * 0.3;
          const blueIntensity = 0.7 + wave2 * 0.3;
          
          // Set the intensities to create the fill effect
          h1.style.setProperty('--fire-intensity', copperIntensity.toString());
          h1.style.setProperty('--blue-intensity', blueIntensity.toString());
        }
        
        function createLightningBurst(x, y) {
          // Limit concurrent bursts
          if (lightningBursts.length >= PERFORMANCE_CONFIG.maxBursts) {
            lightningBursts.shift();
          }
          
          const burst = { x, y, particles: [], life: 1.0 };
          const numParticles = isLowEndDevice ? 8 : 12; // Reduced particle count
          
          for (let i = 0; i < numParticles; i++) {
            const angle = (Math.PI * 2 * i) / numParticles; // Even distribution
            const length = 25 + Math.random() * 25;
            burst.particles.push({
              x1: x, y1: y,
              targetX2: x + Math.cos(angle) * length,
              targetY2: y + Math.sin(angle) * length,
              currentX2: x, currentY2: y,
              brightness: 0.6 + Math.random() * 0.4
            });
          }
          lightningBursts.push(burst);
        }
        
        function drawLightningSegment(x1, y1, x2, y2, brightness) {
          const segmentLength = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
          if (segmentLength < 5) return; // Skip very short segments
          
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          
          // Simplified jagged line for performance
          const numPoints = Math.max(2, Math.floor(segmentLength / 30));
          for (let i = 1; i <= numPoints; i++) {
            const t = i / numPoints;
            let x = x1 + t * (x2 - x1);
            let y = y1 + t * (y2 - y1);
            
            if (i < numPoints) {
              const offset = Math.min(15, segmentLength * 0.2);
              x += (Math.random() - 0.5) * offset;
              y += (Math.random() - 0.5) * offset;
            }
            ctx.lineTo(x, y);
          }
          
          // Optimized lightning rendering
          ctx.strokeStyle = `rgba(0, 229, 255, ${brightness * 0.7})`;
          ctx.lineWidth = 1 + brightness * 2;
          ctx.shadowColor = 'rgba(0, 229, 255, 0.8)';
          ctx.shadowBlur = 3 + brightness * 8;
          ctx.stroke();
        }
        
        function animate(currentTime) {
          // FPS limiting
          if (currentTime - lastFrameTime < fpsInterval) {
            requestAnimationFrame(animate);
            return;
          }
          
          lastFrameTime = currentTime;
          frameCount++;
          
          // Performance monitoring
          if (frameCount % 60 === 0) {
            actualFPS = 1000 / (currentTime - (lastFrameTime - fpsInterval * 60));
            if (actualFPS < PERFORMANCE_CONFIG.maxFPS * 0.8) {
              // Reduce quality if performance drops
              PERFORMANCE_CONFIG.maxSegments = Math.max(5, PERFORMANCE_CONFIG.maxSegments - 1);
            }
          }
          
          // Clear canvas efficiently
          ctx.clearRect(0, 0, width, height);
          ctx.globalCompositeOperation = 'lighter';
          
          // Lightning trail with movement detection
          if (isMouseMoving) {
            const distMoved = Math.sqrt((mouseX - lastTrailPoint.x) ** 2 + (mouseY - lastTrailPoint.y) ** 2);
            
            if (distMoved > PERFORMANCE_CONFIG.minDistForTrail) {
              lightningSegments.push({ x: mouseX, y: mouseY, life: 1.0 });
              
              // Maintain segment limit
              while (lightningSegments.length > PERFORMANCE_CONFIG.maxSegments) {
                lightningSegments.shift();
              }
              
              lastTrailPoint = { x: mouseX, y: mouseY };
            }
          }
          
          // Decay segments
          for (let i = lightningSegments.length - 1; i >= 0; i--) {
            const segment = lightningSegments[i];
            segment.life -= 0.05;
            
            if (segment.life <= 0) {
              lightningSegments.splice(i, 1);
              continue;
            }
            
            if (i > 0) {
              const prevSegment = lightningSegments[i - 1];
              drawLightningSegment(segment.x, segment.y, prevSegment.x, prevSegment.y, segment.life);
            }
          }
          
          // Lightning bursts with cleanup
          for (let i = lightningBursts.length - 1; i >= 0; i--) {
            const burst = lightningBursts[i];
            burst.life -= 0.04;
            
            if (burst.life <= 0) {
              lightningBursts.splice(i, 1);
              continue;
            }
            
            const progress = 1 - burst.life;
            burst.particles.forEach(particle => {
              particle.currentX2 = particle.x1 + (particle.targetX2 - particle.x1) * progress;
              particle.currentY2 = particle.y1 + (particle.targetY2 - particle.y1) * progress;
              drawLightningSegment(particle.x1, particle.y1, particle.currentX2, particle.currentY2, 
                                  burst.life * particle.brightness);
            });
          }
          
          // Check if mouse stopped moving
          if (Date.now() - lastMoveTime > 100) {
            isMouseMoving = false;
          }
          
          ctx.globalCompositeOperation = 'source-over';
          requestAnimationFrame(animate);
        }
        
        // Event listeners with passive option for performance
        window.addEventListener('mousemove', throttledMouseMove, { passive: true });
        
        window.addEventListener('click', (e) => {
          createLightningBurst(e.clientX, e.clientY);
        }, { passive: true });
        
        window.addEventListener('resize', () => {
          ({ width, height } = updateCanvasSize());
          lastTrailPoint = { x: mouseX, y: mouseY };
        }, { passive: true });
        
        // Cleanup for page visibility changes
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            lightningSegments.length = 0;
            lightningBursts.length = 0;
            if (mouseMoveThrottle) {
              clearTimeout(mouseMoveThrottle);
              mouseMoveThrottle = null;
            }
          }
        });
        
        // Start animation
        requestAnimationFrame(animate);
        
        // Cleanup on beforeunload
        window.addEventListener('beforeunload', () => {
          lightningSegments.length = 0;
          lightningBursts.length = 0;
          if (mouseMoveThrottle) {
            clearTimeout(mouseMoveThrottle);
          }
        });
        
      })();
    </script>
  </body>
</html>
